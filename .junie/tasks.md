# Current Status

## Next Steps (Sprint)
- [X] Contract Tests now contain LunyScript tests which should not be there => separate contract from implementation tests
- [X] Move LunyEngine tests from Luny-ContractTest to Luny-Test
- [X] *BridgeTest: should they inherit from ContractTestBase? (YES)
- [X] Remove LunyTestableAttribute (unused, we now have tests in separate projects)
- [X] Check if we can make the native engine projects build by providing Mocks for native APIs (enables engine-wide refactoring!)
- [X] LunyServiceRegistry: refactor engine check, remove adapter and replace with global "engine name" property provided by adapter
- [X] refactor existing *-Test tests:
  - [X] make tests use contract test infrastructure
  - [X] make all tests run once with each engine adapter, without duplicating the test code
  - [X] where it makes sense, move tests to Luny-ContractTest
- [X] GetAllObjects(): change to only convert to LunyObject if scripted
- [X] LunyObject: return cached instance before creating new one
- [X] Implement FindByName (with proxy fallback) for Object.Create that should run a script (consider prebuilt scripts)
- [X] Implement Every.TimeInterval block
- [X] LunyScript.When.Self (updates) should not run while disabled
- [X] Create object via API and register (activate script)
- [X] Get and destroy registered object via API

## Backlog
- ### Unit Testing
  - [ ] add more LunyEngine agnostic tests to define native-engine contracts
  - [ ] create separate Unity package / Godot addon for ContractTests
  - [ ] port agnostic tests to use engine mocks of native implementations (problems: Godot has no unit testing, Unity's requires enumerator tests)
- ### Assets
  - [ ] Implement Asset/Resource loading by name/path
  - [ ] Return valid "error" objects from Asset service
- ### Design & Lifecycle
    - [ ] call OnReady for children first (depth-first, post-order)
    - [ ] ensure deterministic LunyScript execution order (follow scene hierarchy order?)
    - [ ] test LunyScript running on global object (autoload, DDOL) - should still run after scene (re)load
    - [ ] Sandboxed script execution (Limit access to objects, assets, API)
    - [ ] Register/create/enable API methods for engine-native code
    - [ ] Handle LunyObject parenting with hierarchy gaps
    - [ ] Review OnIntervalUpdate implementation in script Scheduler and object event handler
- ### Registries
    - [ ] LunyObjectRegistry: GetByName should use Dictionary, not FirstOrDefault
- ### Services
    - [ ] Scene: implement depth-first enumeration with pre-order or post-order (as IEnumerable?)
- ### LunyScript Blocks & API
    - [ ] [[Conditional Blocks]] (if/else)
    - [ ] [[Composite Blocks]] (loops, timers, coroutines)
    - [ ] [[LunyScript Hot Reload]] with manual triggers
    - [ ] [[Event Handling Blocks]] foundation (Input, Collision, SendMessage)
    - [ ] [[Variable Blocks]]
    - [ ] Variables aliases: `Vars.Global[]` / `Vars.G[]`
    - [ ] Pass scene name to blocks via event parameters
    - [ ] Test scene (re-)load and hook up to scene service callbacks
    - [ ] Create ReloadScene block
    - [ ] Implement Random/Shuffle blocks and API
    - [ ] LunyScript.Every.* (updates) should run unconditionally and globally (not tied to object - but then: context?)
    - [ ] LunyScript.Method.Run => use When/Every overloads in addition? 
- ### Diagnostics & Infrastructure
    - [ ] [[Diagnostics]] Profiling Hooks for scripts and runnables
    - [ ] Internal verbose logging with categories/levels
    - [ ] [[Testing Infrastructure]]
    - [ ] [[Resource Addressing]] (LunyUrl)
    - [ ] [[Lua Integration]]
- ### Improvements & Engine Specific
    - [ ] Unity: Add `[IgnoredByDeepProfiler]` attribute to debug methods
    - [ ] Case insensitive and partial name matching for object-script activator (controlled by LunyScript flags?)
      - [ ] Configurable name matching (starts with/contains)
    - [ ] Variable validation (log read access of non-existing variables)
    - [ ] Metadata for global variable read/write tracking

## Epics
- **Reflective/Generated API**: Lua API generator needed; maybe C# reflected/generated engine bindings? (if it speeds up adding features)
- **Repository Structure**: LunyEngine as separate package from LunyScript
- **Distribution**: versioning of LunyEngine for multiple frameworks? Lightweight package manager?
- **Hot Reload**: Support for both C# and Lua
- **Sandboxed Script Execution**: API filters (Lua blacklist/whitelist, C# custom sandbox service)
- **On-Screen Diagnostics**: Display design and required services
- **Cross-Engine Editor Tooling**: Custom importers, build scripts, editor windows/settings
- **Developer SDK Documentation**: Observer patterns, Service API extension, engine support guide, behavioral contracts
- **Portable Scene Format**: Design in Godot, import in Unity (portable asset types)
- **Ingame Console**: Run blocks/runnables at runtime via console
